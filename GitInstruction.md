# Инструкция по работе с git

## Что это и для чего нужна система контроля версий?

### Что такое система контроля версий?

### Для чего нужна система контроля версий

## Установка git и VSCode на ваш ПК.

### Установка VSCode на ваш ПК.
    1. Открываем сайт VSCode 
    2. Выбираем ОС (необходимую)
    3. Скачиваем установщик на ПК
    4. Установливаем следуя инструкциям установщика
    5. Запускаем VSCode и проверяем работу
    6. Радуемся жизни.    


### Установка git на ваш ПК

#### Первая настройка git

## Создание и базовая работа с локальным репозиторием.

### Что такое репозиторий и инструкция по созданию локальных репозиториев.

Репозиторий Git — это виртуальное хранилище проекта. В нем можно хранить версии кода для доступа по мере необходимости.

Для создания нового репозитория используется команда git init. Команду git init выполняют только один раз для первоначальной настройки нового репозитория. Выполнение команды приведет к созданию нового подкаталога .git в вашем рабочем каталоге. Кроме того, будет создана новая главная ветка.

### Базовая работа с локальным репозиторием

Работа с локальным репозиторием
Базовые команды
git init — создание репозитория
Команда git init создает в директории пустой репозиторий в виде директории .git, где и будет в дальнейшем храниться вся информация об истории коммитов, тегах — о ходе разработки проекта:

mkdir project-dir
cd project-dir
git init
git add и git rm — индексация изменений
Следующее, что нужно знать — команда git add. Она позволяет внести в индекс — временное хранилище — изменения, которые затем войдут в коммит.

Индексирует измененный файл, либо оповещение о создании нового:

git add EDITEDFILE
Вносит в индекс все изменения, включая новые файлы:

git add .
Из индекса и дерева проекта одновременно файл можно удалить командой git rm.

Удаляет из индекса и дерева проекта отдельные файлы:

git rm FILE1 FILE2
Хороший пример удаления из документации к git, удаляются сразу все файлы txt из папки:

git rm Documentation/\*.txt
Вносит в индекс все удаленные файлы:

git rm -r --cached .
Сбросить весь индекс или удалить из него изменения определенного файла можно командой git reset:

git reset
Удаляет из индекса конкретный файл:

git reset — EDITEDFILE
Команда git reset используется не только для сбрасывания индекса, поэтому дальше ей будет уделено гораздо больше внимания.

git status — состояние проекта, измененные и не добавленные файлы, индексированные файлы
Команду git status, пожалуй, можно считать самой часто используемой наряду с командами коммита и индексации. Она выводит информацию обо всех изменениях, внесенных в дерево директорий проекта по сравнению с последним коммитом рабочей ветки; отдельно выводятся внесенные в индекс и неиндексированные файлы. Использовать ее крайне просто:

git status
Кроме того, git status указывает на файлы с неразрешенными конфликтами слияния и файлы, игнорируемые git.

git commit — совершение коммита
Коммит — базовое понятие во всех системах контроля версий, поэтому совершаться он должен легко и по возможности быстро. В простейшем случае достаточно после индексации набрать:

git commit
Если индекс не пустой, то на его основе будет совершен коммит, после чего пользователя попросят прокомментировать вносимые изменения вызовом команды edit. Сохраняемся, и вуаля! Коммит готов. Есть несколько ключей, упрощающих работу с git commit.

Совершает коммит, автоматически индексируя изменения в файлах проекта. Новые файлы при этом индексироваться не будут! Удаление же файлов будет учтено:

git commit -a
Комментирует коммит прямо из командной строки вместо текстового редактора:

git commit -m «commit comment»
Вносит в индекс и создаёт коммит на основе изменений единственного файла:

git commit FILENAME
Пример написания хорошего сообщения коммита:

Описывает изменение (до 50 символов)

Более детальное объяснение, если необходимо. Перенос на 72 символе
или около того. В некоторых контекстах первая строка рассматривается
как тема письма, а остальное как тело. Пустая строка, отделяющая сводку
от тела, важна (если вы не опустили тело целиком); если вы оставите их
вместе, инструменты, такие как rebase, могут воспринять это неправильно.

Дальнейшие параграфы идут после пустых строк

 - также можно применять маркеры списков

 - обычно в качестве маркера списка используется дефис или звёздочка
   с одним пробелом перед ним и пустыми строками между пунктами,
   хотя соглашения в этом аспекте могут разниться

Если вы используете систему отслеживания задач, поставьте ссылки на нее:

Resolves: #123
See also: #456, #789
git reset — возврат к определенному коммиту, откат изменений, «жесткий» или «мягкий»
Помимо работы с индексом (см. выше), git reset позволяет сбросить состояние проекта до какого-либо коммита в истории. В git данное действие может быть двух видов: «мягкого»(soft reset) и «жесткого» (hard reset).

«Мягкий» (с ключом --soft) резет оставит нетронутыми ваши индекс и все дерево файлов и директорий проекта, вернется к работе с указанным коммитом. Иными словами, если вы обнаруживаете ошибку в только что совершенном коммите или комментарии к нему, то легко можно исправить ситуацию:

Некорректный коммит
git commit
Переход к работе над уже совершенным коммитом, сохраняя все состояние проекта и проиндексированные файлы
git reset --soft HEAD^
Редактирование файла или файлов
Добавление файлов в индекс
git add .
Возврат к последнему коммиту, будет предложено отредактировать его сообщение
git commit -c ORIG_HEAD
Если сообщение оставить прежним, то достаточно изменить регистр ключа -с
git commit -C ORIG_HEAD
Обратите внимание на обозначение HEAD^, оно означает «обратиться к предку последнего коммита». Подробней описан синтаксис такой относительной адресации будет ниже, в разделе «Хэши, тэги, относительная адресация». Соответственно, HEAD — ссылка на последний коммит. Ссылка ORIG_HEAD после «мягкого» резета указывает на оригинальный коммит.

Естественно, можно вернуться и на большую глубину коммитов,

«Жесткий» резет (ключ --hard) — команда, которую следует использовать с осторожностью. git reset --hard вернет дерево проекта и индекс в состояние, соответствующее указанному коммиту, удалив изменения последующих коммитов:

git add .
git commit -m «destined to death»
git reset --hard HEAD~1 — больше никто и никогда не увидит этот позорный коммит...
git reset --hard HEAD~3 — ...вернее, три последних коммита. Никто. Никогда!
Если команда достигнет точки ветвления, удаления коммита не произойдет.

Для команд слияния или выкачивания последних изменений с удаленного репозитория примеры резета будут приведены в соответствующих разделах.

git revert — отмена изменений, произведенных в прошлом отдельным коммитом
Возможна ситуация, в которой требуется отменить изменения, внесенные отдельным коммитом. git revert создает новый коммит, накладывающий обратные изменения.

Отменяет коммит, помеченный тегом:

git revert config-modify-tag
Отменяет коммит, используя его хэш:

git revert cgsjd2h
Для отмены коммита слияния (коммита у которого несколько родителей), необходимо указать хэш и номер одного из родителей коммита:

git revert cgsjd2h -m 1
Для использования команды необходимо, чтобы состояние проекта не отличалось от состояния, зафиксированного последним коммитом.

git log — разнообразная информация о коммитах в целом
Иногда требуется получить информацию об истории коммитов; коммитах, изменивших отдельный файл; коммитах за определенный отрезок времени и так далее. Для этих целей используется команда git log.

Простейший пример использования, в котором приводится короткая справка по всем коммитам, коснувшимся активной в настоящий момент ветки (о ветках и ветвлении подробно узнать можно ниже, в разделе «Ветвления и слияния»):

git log
Получает подробную информацию о каждом в виде патчей по файлам из коммитов можно, добавив ключ -p (или -u):

git log -p
Статистика изменения файлов, вроде числа измененных файлов, внесенных в них строк, удаленных файлов вызывается ключом --stat:

git log --stat
За информацию по созданиям, переименованиям и правам доступа файлов отвечает ключ --summary:

git log --summary
Чтобы просмотреть историю отдельного файла, достаточно указать в виде параметра его имя (кстати, в моей старой версии git этот способ не срабатывает, обязательно добавлять " — " перед «README»):

git log README
или, если версия git не совсем свежая:

git log — README
Далее приводится только более современный вариант синтаксиса. Возможно указывать время, начиная в определенного момента («weeks», «days», «hours», «s» и так далее):

git log --since=«1 day 2 hours» README
git log --since=«2 hours» README
изменения, касающиеся отдельной папки:

git log --since=«2 hours» dir/
Можно отталкиваться от тегов.

Все коммиты, начиная с тега v1:

git log v1...
Все коммиты, включающие изменения файла README, начиная с тега v1:

git log v1... README
Все коммиты, включающие изменения файла README, начиная с тега v1 и заканчивая тегом v2:

git log v1..v2 README
Интересные возможности по формату вывода команды предоставляет ключ --pretty.

Выводит на каждый из коммитов по строчке, состоящей из хэша (здесь — уникального идентификатора каждого коммита, подробней — дальше):

git log --pretty=oneline
Лаконичная информация о коммитах, приводятся только автор и комментарий:

git log --pretty=short
Более полная информация о коммитах, с именем автора, комментарием, датой создания и внесения коммита:

git log --pretty=full/fuller
В принципе, формат вывода можно определить самостоятельно:

git log --pretty=format:'FORMAT'
Определение формата можно поискать в разделе по git log из Git Community Book или справке. Красивый ASCII-граф коммитов выводится с использованием ключа --graph.

git diff — отличия между деревьями проекта, коммитами и т.д.
Своего рода подмножеством команды git log можно считать команду git diff, определяющую изменения между объектами в проекте - деревьями (файлов и директорий).

Показывает изменения, не внесенные в индекс:

git diff
Изменения, внесенные в индекс:

git diff --cached
Изменения в проекте по сравнению с последним коммитом:

git diff HEAD
Предпоследним коммитом:

git diff HEAD^
Можно сравнивать «головы» веток:

git diff master..experimental
или активную ветку с какой-либо:

git diff experimental
git show — показать изменения, внесенные отдельным коммитом
Посмотреть изменения, внесенные любым коммитом в истории, можно командой git show:

git show COMMIT_TAG
git blame и git annotate — команды, помогающие отслеживать изменения файлов
При работе в команде часто требуется выяснить, кто именно написал конкретный код. Удобно использовать команду git blame, выводящую построчную информацию о последнем коммите, коснувшемся строки, имя автора и хэш коммита:

git blame README
Можно указать и конкретные строки для отображения:

git blame -L 2,+3 README — выведет информацию по трем строкам, начиная со второй.
Аналогично работает команда git annotate, выводящая и строки, и информацию о коммитах, их коснувшихся:

git annotate README
git grep — поиск слов по проекту, состоянию проекта в прошлом
git grep, в целом, просто дублирует функционал знаменитой юниксовой команды. Однако он позволяет слова и их сочетания искать в прошлом проекта, что бывает очень полезно.

Ищет слова tst в проекте:

git grep tst
Подсчитывает число упоминаний tst в проекте:

git grep -с tst
Ищет в старой версии проекта:

git grep tst v1
Команда позволяет использовать логическое И и ИЛИ.

Ищет строки, где упоминаются и первое слово, и второе:

git grep -e 'first' --and -e 'another'
Ищет строки, где встречается хотя бы одно из слов:

git grep --all-match -e 'first' -e 'second'

## Ветки. Локальная работа с ветками в git.

### Что такое ветки и для чего они нужны при работе с системой контроля версий.

### Базовая работа с ветками в git.

**git branch** -- показывает все ветки проекта и в какой ветке ведется работа сейчас. Если такой ветки не существует - создает ветку. Имеет кучу дополнительных параметров.

**git merge** -- сливает ветки друг с другом. Работает по принцу "добавить к ветке, на которой ведется работа, ветку, имя которой указано в команде". Конфликты можно разрешить вручную.


## Работа с удаленными репозиториями.

### Что такое удаленный репозиторий и для чего он нужен

### Базовая работа с удаленными репозиториями GitHub

на сайте GitHub создать репозиторий, далее в VSC склонировать репозиторий, создать отдельную ветку и вносить свои изменения.

## Совместная работа над проектом (fork, pull request)

### Как строится и для чего нужна совместная работа в системах контроля версий

### Инструкция по созданию pull request

1. На Github делаем Fork репозитория
2. Копируем ссылку удаленного репозитория

3. Открываем папку и терминал редактора исходного кода

4. Вводим команду в терминале, которой выполняем копирование удаленного репозитория
    
    git clone <Ссылка на удаленный репозиторий>

5. Вводим команду в терминале, которой переключаемся с изначальной открытой папки на репозиторий, который скопировали:

    cd <Наименование скопированного репозитория>

6. Создаем ветку, в которой разрабатываем код:

    git branch <Наименование ветки>

7. Сохраняем изменения в созданной ветке:

    git add <Наименование папки>
    
    gid commit -m "Комментарий к сохранению"

8. Отправляем локальный репозиторий на Github

    git push

9. В удаленном репозитории на Githum нажимаем кнопку "Contribute", затем кнопку "Open pull request"

10. Добавляем комментарий к своему Fork и нажаимаем кнопку "Create pull request"

## Книги и полезные ссылки по изучению git.

## Альтернативные системы контроля версий.
